-- Data Synchronization with DBMS_AQ - Simple Example
-- ================================================
-- This demonstrates Oracle Advanced Queuing for data synchronization
-- between different systems (e.g., database to data warehouse, system A to system B).

-- 0. Setup: Create schema
-- =======================

-- Create user
create user "AQ_DEMO" identified by "Password123*";

grant create session, create table, create type, create procedure, create sequence, create trigger to "AQ_DEMO";
grant execute on dbms_aqadm to "AQ_DEMO";
grant execute on dbms_aq to "AQ_DEMO";

-- Grant tablespace privileges
grant unlimited tablespace to "AQ_DEMO";


-- Set current schema
alter session set current_schema = AQ_DEMO;

-- 1. Sync Operations Table
-- =======================
create table sync_operations (
    id                          number generated by default on null as identity (start with 1) primary key not null
  , source_system               varchar2(50 char)          not null
  , target_system               varchar2(50 char)          not null
  , sync_type                   varchar2(30 char)          not null
  , record_count                number                     not null
  , sync_status                 varchar2(20 char)          default 'COMPLETED' not null
  , created_by                  varchar2(60)               default coalesce(
                                    sys_context('APEX$SESSION','app_user')
                                  , regexp_substr(sys_context('userenv','client_identifier'),'^[^:]*')
                                  , sys_context('userenv','session_user')
                                ) not null
  , created_on                  timestamp with local time zone default localtimestamp not null
  , constraint chk_sync_operations_status check (sync_status in ('PENDING','PROCESSING','COMPLETED','FAILED'))
  , constraint chk_sync_operations_type check (sync_type in ('FULL','INCREMENTAL','DELTA','REALTIME'))
);

comment on table sync_operations is 'Records of data synchronization operations between systems.';
comment on column sync_operations.source_system is 'The system where data originates from.';
comment on column sync_operations.target_system is 'The system where data is synchronized to.';
comment on column sync_operations.sync_type is 'Type of sync: FULL, INCREMENTAL, DELTA, or REALTIME.';
comment on column sync_operations.record_count is 'Number of records synchronized.';
comment on column sync_operations.sync_status is 'Current status of the synchronization operation.';

-- 2. Sync Task Message Type
-- ==========================
create or replace type sync_task_type as object (
    source_system              varchar2(50)
  , target_system              varchar2(50)
  , sync_type                  varchar2(30)
  , record_count               number
  , priority                   number
);
/
-- 3. Create Queue
-- ===============
begin
  -- Create queue table
  dbms_aqadm.create_queue_table(
    queue_table        => 'AQ_DEMO.SYNC_QUEUE_TABLE',
    queue_payload_type => 'AQ_DEMO.SYNC_TASK_TYPE',
    multiple_consumers => false,
    comment            => 'Queue table for data synchronization tasks'
  );
end;
/
begin
  -- Create queue with retry configuration
  dbms_aqadm.create_queue(
    queue_name     => 'AQ_DEMO.SYNC_QUEUE',
    queue_table    => 'AQ_DEMO.SYNC_QUEUE_TABLE',
    max_retries    => 3,        -- Maximum number of retry attempts
    retry_delay    => 30,       -- Delay in seconds between retries
    retention_time => 3600,     -- Retention time in seconds (1 hour)
    comment        => 'Queue for data synchronization tasks with retry configuration'
  );
end;
/
begin
  -- Start the queue
  dbms_aqadm.start_queue('AQ_DEMO.SYNC_QUEUE');
end;
/
begin
  -- Update retry configuration
  dbms_aqadm.alter_queue(
    queue_name     => 'AQ_DEMO.SYNC_QUEUE',
     max_retries    => 5       -- Changed from 3 to 5
     , retry_delay    => 0       -- Changed from 30 to 60 seconds
    --, retention_time => 15      -- Changed from 3600 to 7200 seconds (2 hours)
  );
  commit;
  dbms_output.put_line('Queue configuration updated successfully');
end;
/


-- 5. AQ Notification Callback
-- ============================
create or replace procedure sync_callback(
    context   in raw
  , reginfo   in sys.aq$_reg_info
  , descr     in sys.aq$_descriptor
  , payloadl  in number
  , payload   in varchar2
) as
  l_message sync_task_type;
  l_dequeue_options dbms_aq.dequeue_options_t;
  l_message_props   dbms_aq.message_properties_t;
  l_message_id      raw(16);

  l_sync_type       varchar2(100);
begin
  dbms_output.put_line('Sync callback triggered at ' || to_char(systimestamp, 'HH24:MI:SS'));
  logger.log(' .. AAA START dbms_aq.LOCKED: ' || l_sync_type);


  -- Configure dequeue options
  -- WAIT: Controls how long to wait for messages
  --   • NO_WAIT: Return immediately if no message available
  --   • FOREVER: [default] Wait indefinitely for a message
  --   • Number: Wait specified seconds (0-4294967295)
  l_dequeue_options.wait := dbms_aq.no_wait;
  
  -- NAVIGATION: Which message to retrieve from queue
  --   • FIRST_MESSAGE: [default] Get first available message
  --   • NEXT_MESSAGE: Get next message in sequence
  --   • FIRST_MESSAGE_MULTI_GROUP: First message across consumer groups
  --   • NEXT_MESSAGE_MULTI_GROUP: Next message across consumer groups
  --l_dequeue_options.navigation := dbms_aq.first_message;
  
  -- VISIBILITY: When dequeue operation becomes visible to other transactions
  --   • ON_COMMIT: [default] Changes visible only after transaction commit
  --   • IMMEDIATE: Changes visible immediately
  l_dequeue_options.visibility := dbms_aq.on_commit;
  
  -- DEQUEUE_MODE: What happens to the message after dequeue
  --   • BROWSE: Read message but keep it in queue
  --   • LOCKED: Lock message for exclusive access
  --   • REMOVE: [default] Delete message after reading
  --   • REMOVE_NODATA: Delete message but don't return payload
  l_dequeue_options.dequeue_mode := dbms_aq.remove;
  
  -- DELIVERY_MODE: How messages are stored and delivered
  --   • PERSISTENT: [default] Messages stored in database tables (durable)
  --   • BUFFERED: Messages kept in memory (faster)
  --   • PERSISTENT_OR_BUFFERED: Use either mode as appropriate
  --l_dequeue_options.delivery_mode := dbms_aq.persistent;
  
  -- Additional dequeue options available:
  -- l_dequeue_options.consumer_name := 'consumer_name';  -- Target specific consumer in multi-consumer queues
  -- l_dequeue_options.msgid := raw_message_id;           -- Dequeue specific message by its unique ID
  -- l_dequeue_options.correlation := 'correlation_id';   -- Filter messages by correlation identifier
  -- l_dequeue_options.deq_condition := 'priority > 5';   -- SQL WHERE condition to filter which messages to dequeue
  -- l_dequeue_options.transformation := 'transform_name'; -- Apply transformation function to message payload before returning

  -- Available descriptor properties for logging/debugging:
  -- descr.msg_id          - Message ID (RAW)
  -- descr.queue_name      - Queue name where message is located
  -- descr.consumer_name   - Consumer name (for multi-consumer queues)
  -- Note: msg_priority and msg_state are not directly available on descriptor
  
  
  logger.log('msg_id: ' || descr.msg_id);
/*   logger.log('queue_name: ' || descr.queue_name);
  logger.log('consumer_name: ' || descr.consumer_name);
  logger.log('payload: ' || payload);
  logger.log('payloadl: ' || payloadl);
   */
  l_dequeue_options.msgid := descr.msg_id;

  -- Dequeue the message
  dbms_aq.dequeue(
      queue_name         => 'AQ_DEMO.SYNC_QUEUE'
    , dequeue_options    => l_dequeue_options
    , message_properties => l_message_props
    , payload            => l_message
    , msgid              => l_message_id
  );
  l_sync_type := l_message.sync_type;

  -- Process the sync task
  insert into sync_operations (source_system, target_system, sync_type, record_count, sync_status)
  values (l_message.source_system, l_message.target_system, l_message.sync_type, l_message.record_count, 'COMPLETED');

  dbms_output.put_line('Sync operation completed: ' || l_message.source_system || ' -> ' || l_message.target_system);
  raise_application_error(-20001,'abc');
  --commit;
exception
  when others then
    --rollback;
    dbms_output.put_line('Error in sync callback: ' || sqlerrm);
    logger.log_error(' .. AAA END dbms_aq.LOCKED: ' || l_sync_type);
    raise;
end;
/

-- 6. Register Notification
-- ========================
begin
  dbms_aq.register(
      sys.aq$_reg_info_list(
          sys.aq$_reg_info(
              'AQ_DEMO.SYNC_QUEUE'
            , dbms_aq.namespace_aq
            , 'PLSQL://AQ_DEMO.SYNC_CALLBACK'
            , null
          )
      )
    , 1
  );
  dbms_output.put_line('Sync notification registered');
end;
/

-- 7. Sync API - Queue Sync Task
-- =============================
create or replace procedure queue_sync_task(
    p_source_system in varchar2
  , p_target_system in varchar2
  , p_sync_type     in varchar2
  , p_record_count  in number
  , p_priority      in number default 5
) as
  l_enqueue_options dbms_aq.enqueue_options_t;
  l_message_props   dbms_aq.message_properties_t;
  l_message         sync_task_type;
  l_msgid           raw(16);
begin
  dbms_output.put_line('Queueing sync task: ' || p_source_system || ' -> ' || p_target_system);

  -- Create sync task message
  l_message := sync_task_type(
      source_system => p_source_system,
      target_system => p_target_system,
      sync_type     => p_sync_type,
      record_count  => p_record_count,
      priority      => p_priority
  );

  -- Configure enqueue options
  l_enqueue_options.visibility := dbms_aq.on_commit;

  -- Enqueue the sync task
  dbms_aq.enqueue(
      queue_name         => 'AQ_DEMO.SYNC_QUEUE'
    , enqueue_options    => l_enqueue_options
    , message_properties => l_message_props
    , payload            => l_message
    , msgid              => l_msgid
  );

  commit;
  dbms_output.put_line('Sync task queued successfully');

exception
  when others then
    rollback;
    dbms_output.put_line('Error queueing sync task: ' || sqlerrm);
    raise;
end;
/

-- 8. Validation and Testing
-- ==========================================================================================
prompt '=== DATA SYNCHRONIZATION AQ SETUP COMPLETE ==='
prompt ''

-- Validate setup
select 'Message type exists: ' || count(*) as validation
from user_types
where type_name = 'SYNC_TASK_TYPE';

select *
from all_queues -- user_queues
where name = 'SYNC_QUEUE';

select *
from all_queue_tables -- user_queue_tables
where queue_table = 'SYNC_QUEUE_TABLE';


prompt ''
prompt '=== TESTING DATA SYNCHRONIZATION ==='

-- Test sync tasks
begin
  queue_sync_task('CRM_SYSTEM', 'DATA_WAREHOUSE', 'INCREMENTAL', 1250, 3);
  queue_sync_task('ERP_SYSTEM', 'ANALYTICS_DB', 'FULL', 50000, 5);
  queue_sync_task('WEB_APP', 'BACKUP_SYSTEM', 'DELTA', 340, 1);
end;
/

-- Wait a moment for processing
dbms_lock.sleep(2);

-- Check results
prompt ''
prompt '=== SYNC OPERATIONS COMPLETED ==='
select
    id
  , source_system
  , target_system
  , sync_type
  , record_count
  , sync_status
  , created_on
from sync_operations
order by created_on desc;

prompt ''
prompt '=== QUEUE STATUS ==='
select
    treat(user_data as sync_task_type).source_system as source_system
  , treat(user_data as sync_task_type).target_system as target_system
  , treat(user_data as sync_task_type).sync_type as sync_type
  , treat(user_data as sync_task_type).record_count as record_count
  , enq_time
  , deq_time
  , retry_count
  , msg_state
from aq$sync_queue_table
order by enq_time desc;

prompt ''
prompt '=== RETRY CONFIGURATION ==='
select *
    --name,
    --max_retries,
    --retry_delay
    --retention_time
from all_queues
where name = 'SYNC_QUEUE';

--
 select * from DBA_QUEUE_TABLES


prompt ''
prompt '=== SYSTEM READY ==='
prompt 'Use QUEUE_SYNC_TASK procedure to queue new synchronization tasks'
prompt 'Sync tasks will be automatically processed via AQ callback'
